# coding: utf-8

"""
    Suger API

    CRUD operations on a set of resources, including organizations, products, offers, entitlements, usage record groups for meterting, etc.

    The version of the OpenAPI document: 1.0
    Contact: support@suger.io
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import List, Optional
from pydantic import BaseModel, Field, StrictInt, StrictStr, conlist
from openapi_client.models.types_usage_allocation import TypesUsageAllocation


class TypesUsageRecord(BaseModel):
    """
    TypesUsageRecord
    """

    customer_identifier: Optional[StrictStr] = Field(
        None,
        alias="customerIdentifier",
        description="The CustomerIdentifier is obtained through the ResolveCustomer operation and represents an individual buyer in your application.  This member is required.",
    )
    dimension: Optional[StrictStr] = Field(
        None,
        description="During the process of registering a product on AWS Marketplace, dimensions are specified. These represent different units of value in your application.  This member is required.",
    )
    quantity: Optional[StrictInt] = Field(
        None,
        description="The quantity of usage consumed by the customer for the given dimension and time. Defaults to 0 if not specified.",
    )
    timestamp: Optional[StrictStr] = Field(
        None,
        description="Timestamp, in UTC, for which the usage is being reported. Your application can meter usage for up to one hour in the past. Make sure the timestamp value is not before the start of the software usage.  This member is required.",
    )
    usage_allocations: Optional[conlist(TypesUsageAllocation)] = Field(
        None,
        alias="usageAllocations",
        description="The set of UsageAllocations to submit. The sum of all UsageAllocation quantities must equal the Quantity of the UsageRecord.",
    )
    __properties = [
        "customerIdentifier",
        "dimension",
        "quantity",
        "timestamp",
        "usageAllocations",
    ]

    class Config:
        """Pydantic configuration"""

        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> TypesUsageRecord:
        """Create an instance of TypesUsageRecord from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of each item in usage_allocations (list)
        _items = []
        if self.usage_allocations:
            for _item in self.usage_allocations:
                if _item:
                    _items.append(_item.to_dict())
            _dict["usageAllocations"] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> TypesUsageRecord:
        """Create an instance of TypesUsageRecord from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return TypesUsageRecord.parse_obj(obj)

        _obj = TypesUsageRecord.parse_obj(
            {
                "customer_identifier": obj.get("customerIdentifier"),
                "dimension": obj.get("dimension"),
                "quantity": obj.get("quantity"),
                "timestamp": obj.get("timestamp"),
                "usage_allocations": [
                    TypesUsageAllocation.from_dict(_item)
                    for _item in obj.get("usageAllocations")
                ]
                if obj.get("usageAllocations") is not None
                else None,
            }
        )
        return _obj
